* 前端异常监控  
  代码运行错误通常的办法是使用window.onerror拦截报错，对于异步代码，可以使用catch方式捕获错误，async await就使用try catch

* UDP与TCP的区别是什么？  
  UDP协议是面向无连接的，不需要在正式传递数据之前先链接起双方。UDP协议只是数据报文的搬运工，不保证有序且不丢失的传递到对端，并且UDP协议也没有任何控制流量的算法，总的来说UDP相对于TCP更加轻便。  
  i. 面向无连接。  
  ii. 不可靠性。通信都不需要建立连接，想发就发。  
  iii. 高效。没有TCP那么复杂，需要保证数据不丢失且有序到达。因此UDP的头部开销小，只有八字节，相比TCP的至少二十字节要少得多，在传输数据报文时是很高效的。  
  vi. 传输方式。不止支持一对一，同样还支持一对多，多对多，多对一的方式。


* TCP连接的建立，三次握手过程。(https://blog.csdn.net/qq_38950316/article/details/81087809)  
  由于TCP是有状态的一来一回的连接，只有客户端才能先行发起。
  i. 第一次握手：建立连接时，客户端发送syn包（syn=j）到服务器，并进入SYN_SENT状态，等待服务器确认；SYN：同步序列编号（Synchronize Sequence Numbers）
  ii. 第二次握手：服务器收到syn包，必须确认客户的SYN（ack=j+1），同时自己也发送一个SYN包（syn=k），即SYN+ACK包，此时服务器进入SYN_RECV状态；
  iii. 第三次握手：客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack=k+1），此包发送完毕，客户端和服务器进入ESTABLISHED（TCP连接成功）状态，完成三次握手。

* TCP连接的关闭，四次挥手过程，断开的过程，客户端和服务端都可以发起  
  i.客户端发送 Fin 字段告诉服务端，希望关闭连接，客户端处理 Fin wait 1 阶段（终止等待第一阶段）；  
  ii. 服务端收到信号，返回 ack 确认包给客户端，并告诉客户端服务端仍可能有上次的数据未处理完毕，我正在处理中，你仍可以接收我可能发给你客户端的数据，我先处于 close wait状态直至我处理完毕，客户端当前处于终止 Fin wait 1 阶段，进入 Fin wait 2 阶段（终止等待第二阶段）；  
  iii. 服务端在处理完之前的数据后，发送 Fin 信号以及 ack 确认包给客户端，告诉客户端服务端已经处理完毕，已经可以开始关闭连接了；  
  iv. 客户端收到服务端发来的 Fin 信号后，再次向服务端发送 ack 确认包，告诉服务端自己已经收到关闭命令了，自己正在执行关闭连接的过程，此时客户端处于 Time wait 阶段，等待关闭连接，服务端收到 ack 后立刻就关闭了 TCP 连接，在等待了 2MSL（最长报文段寿命） 后，客户端也关闭了 TCP 连接；

* 为什么连接的时候要三次握手，关闭的时候要四次握手  
  i.三次握手的过程缺一不可，第一次客户端发送请求，第二次服务端确认连接请求，第三次客户端确认可连接请求，清洗可见上面的 TCP 连接建立过程，其中少一个步骤都无法建立，多一个步骤则造成冗余，降低效率；  
  ii. 四次握手都是必须的，第一次终止信号是必须的，这个不用说，第二次服务端仍可能在处理上次的连接，所以 ack 确认包告诉客户端已经确认，但是请等待我处理完这是必须的，处理完毕后第三次发送 Fin 信号告诉客户端我可以关闭了，第二与第三次是不能一起发送的，因为要等待服务端将可能剩余的报文处理完毕；  
  有疑问的只有第四次，为什么客户端还要发送 ack 确认包给服务端，确认服务端收到才完全关闭？这是因为我们要假定网络是不可靠的，可能存在掉线的可能，所以最后一次客户端要确认服务端再次收到后才能关闭，否则客户端将一直重发第四次的 ack 包去确认服务端仍在线并接收到了，直至服务端确认了，客户端才彻底关闭连接，第四次的等待确认时间是 2MSL（MSL 指一个片段在网络中的最大存活时间，2 倍是因为第四次 客户端 发送 ack 给服务端后，此时服务端知道可以完全关闭连接了，就会关闭并且不会再回复 Fin 信号回去，而客户端在没有等待到最后一次 Fin 信号时就知道服务端肯定是收到第四次的 ack 包，自己也可以放心的完全关闭连接了），所以客户端在第四次等待的 2MSL 一个是 ack 发送的时间，一个是确认服务端没掉线，自己等待不会到的 Fin 信号的时间。

* 为什么TCP建立连接需要三次握手，明明2次就可以了  
  因为这是为了防止出现失效的连接请求报文段被服务端接收的情况，从而产生错误。客户端在网络超时的时候会启动超时重传机制再次发送一个请求，如果之前的请求在两端关闭后才到达服务端，服务端端以为客户端又需要建立TCP链接，就会进入等待，造成资源的浪费。

* http2 与 http1.X 相比的新特性

  **新的二进制格式（Binary Format** HTTP1.x的解析是基于文本。基于文本协议的格式解析存在天然缺陷，文本的表现形式有多样性，要做到健壮性考虑的场景必然很多，二进制则不同，只认0和1的组合。基于这种考虑HTTP2.0的协议解析决定采用二进制格式，实现方便且健壮。

  **多路复用（MultiPlexing）** 即连接共享，即每一个request都是是用作连接共享机制的。一个request对应一个id，这样一个连接上可以有多个request，每个连接的request可以随机的混杂在一起，接收方可以根据request的 id将request再归属到各自不同的服务端请求里面。

  **header压缩**，如上文中所言， 对前面提到过 HTTP1.x 的header带有大量信息，而且每次都要重复发送，HTTP2.0使用encoder来减少需要传输的header大小，通讯双方各自cache一份header fields表，既避免了重复header的传输，又减小了需要传输的大小。

  **服务端推送（server push）** 同SPDY一样，HTTP2.0也具有server push功能。

* 从浏览器输入URL到页面渲染的整个过程  
  i. DNS解析域名。DNS解析出ip地址，接着应用层会下发数据给传输层，TCP开始三次握手建立TCP连接，建立连接；  
  ii. 发起 TCP 封装到 应用层的 http 协议生成报文；  
  iii. 服务端接收到报文后开始解析 http 请求头，在这个过程中，浏览器先根据请求头查看 cache control 与 expires 字段查看是否具有强缓存，如果有强缓存则直接使用缓存，不用到服务端了，如果没有则查看是否具有协商缓存，服务端通过解析请求头的 If-Modified-Since 与 ETag 判断协议缓存是否过期，若未过期，则返回缓存，并修改响应头 ETag 及 Last-Modified 字段；
  iv. 若两项缓存都没有，则开始解析请求头 MIME（Content-Type） 及请求方式 Type 映射到对应路由（请求地址及请求方式）进行业务处理，对应业务处理完毕后返回响应，这里假设会响应一个HTML文件；
  v. 浏览器接收到响应后，开始渲染 html 文件，由头部开始向下依次解析，浏览器的 5 个线程开始对应处理解析（GUI 渲染、js 引擎、定时器触发、异步请求、事件触发），首先解析 html 标签的指定语言，其次是 head 标签内的 meta 元标签信息及 css 等，其次到 body 中的内容，最后解析最下面的 js 脚本，将 js 放在最下面是因为 js 可能会阻塞 GUI 渲染的过程（阻碍 DOM 解析），因为 js 中可能会操作 DOM 及出现动态渲染，并且 js 一般较大，为了减少白屏的时间，我们选择先让浏览器渲染出静态可见的内容，然后在最后才去渲染动画等较复杂的行为；